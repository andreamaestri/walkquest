{% extends "base.html" %}
{% load static %}

{% block title %}Walks - WalkQuest{% endblock title %}

{% block extra_css %}
<style>
    /* Map container styles */
    #map {
        width: 100%;
        height: 100%;  /* Changed from 100vh */
        position: relative;  /* Changed from absolute */
    }

    /* Ensure map elements are visible */
    #map > *:not(.mapboxgl-map):not(.mapboxgl-control-container) {
        z-index: 1;
    }

    /* Layout structure */
    .layout-container {
        height: 100vh;  /* Changed from calc */
        width: 100vw;
        display: flex;
        position: relative;
        overflow: hidden;  /* Add this to prevent scrolling issues */
    }

    /* Sidebar styles */
    .sidebar {
        width: 24rem;
        height: 100%;  /* Changed from specific height */
        flex-shrink: 0;  /* Add this to prevent sidebar from shrinking */
        z-index: 10;
        background: white;
        display: flex;
        flex-direction: column;
        box-shadow: 2px 0 10px rgba(0,0,0,0.1);
    }

    /* Map wrapper styles */
    .map-wrapper {
        flex: 1;
        position: relative;  /* Ensure this is relative */
        height: 100%;  /* Add this */
    }

    /* Existing styles */
    .walk-card {
        background: white;
        transition: all 0.2s;
    }

    .walk-card:hover {
        transform: translateY(-1px);
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .walk-card--selected {
        border-left: 4px solid #4F46E5;
    }

    .filter-option {
        transition: all 0.2s;
    }

    .filter-option:hover {
        background-color: #F3F4F6;
    }

    .count {
        color: #6B7280;
        font-size: 0.875rem;
        margin-left: auto;
    }

    .loading::after {
        content: '';
        position: absolute;
        inset: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Tag Cloud Styles */
    .filter-option {
        transition: all 0.2s ease;
    }

    .filter-option:hover {
        background-color: #F3F4F6;
    }

    .filter-option input:checked + span {
        color: #4F46E5;
        font-weight: 600;
    }

    .filter-option.selected {
        background-color: #EEF2FF;
        border-color: #4F46E5;
    }
</style>
{% endblock extra_css %}

{% block content %}
    <!-- Embed JSON data without extra <script> tags -->
    {% if config %}
        {{ config|json_script:"config-data" }}
    {% endif %}
    
    {% if initial_walks %}
        {{ initial_walks|json_script:"walks-data" }}
    {% endif %}

    <!-- Add this near the other JSON data scripts -->
    {% if tags_data %}
        {{ tags_data|json_script:"tags-data" }}
    {% endif %}

    <!-- Error container -->
    <div id="error-container" class="hidden bg-red-100 border-l-4 border-red-500 text-red-700 p-4" role="alert"></div>

    <!-- Main content with Alpine.js -->
    <div class="layout-container" 
         x-data="walkInterface()"
         x-init="$nextTick(() => init())">
        
        <!-- Sidebar with persisted state -->
        <aside class="sidebar"
               x-show="showSidebar"
               x-transition:enter="transition ease-out duration-300"
               x-transition:enter-start="-translate-x-full"
               x-transition:enter-end="translate-x-0"
               x-transition:leave="transition ease-in duration-300"
               x-transition:leave-start="translate-x-0"
               x-transition:leave-end="-translate-x-full">
            
            <!-- Toggle sidebar button with persisted state -->
            <button @click="showSidebar = !showSidebar"
                    class="absolute -right-12 top-4 bg-white p-2 rounded-r shadow-md"
                    :aria-label="showSidebar ? 'Hide sidebar' : 'Show sidebar'">
                <iconify-icon :icon="showSidebar ? 'mdi:chevron-left' : 'mdi:chevron-right'"
                             class="text-xl"></iconify-icon>
            </button>

            <!-- Search with persisted query -->
            <div class="p-4 border-b">
                <div class="relative">
                    <input type="text" 
                           x-model="searchQuery"
                           x-on:input.debounce.500ms="handleSearch()"
                           hx-post="{% url 'walks:search' %}"
                           hx-trigger="search from:body"
                           hx-target="#walk-list"
                           hx-indicator="#search-indicator"
                           class="w-full px-4 py-2 pl-10 border rounded-lg focus:ring-2 focus:ring-primary-500"
                           placeholder="Search walks..."
                           :disabled="isLoading">
                    <span class="absolute left-3 top-1/2 transform -translate-y-1/2">
                        <svg class="w-4 h-4 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                        </svg>
                    </span>
                    <div id="search-indicator" class="htmx-indicator">
                        <div class="animate-spin h-4 w-4 border-2 border-primary-500"></div>
                    </div>
                </div>
            </div>

            <!-- Filter Sections with persisted selections -->
            <div class="p-4 border-b overflow-y-auto">
                <div x-data="categoryCombobox({
                    options: JSON.parse(document.getElementById('tags-data').textContent).map(tag => ({
                        value: tag.name,
                        label: tag.name,
                        count: tag.count,
                        emoji: getCategoryEmoji(tag.name),
                        color: getCategoryColor(tag.name)
                    }))
                })" class="w-full flex flex-col gap-1">
                    <label class="w-fit pl-0.5 text-sm text-gray-700 flex items-center justify-between">
                        Walk Categories
                        <button type="button" 
                                @click="clearSelection()"
                                x-show="selectedOptions.length"
                                class="text-sm text-primary-500 hover:text-primary-600 ml-2">
                            Clear all
                        </button>
                    </label>
                    
                    <!-- Combobox Container -->
                    <div class="relative"
                         x-on:keydown.escape.prevent.stop="isOpen = false"
                         x-on:focusin.window="!$el.contains($event.target) && (isOpen = false)">
                        <!-- Trigger Button -->
                        <button type="button" 
                                class="inline-flex w-full items-center justify-between gap-2 rounded-md border border-gray-300 bg-white px-4 py-2 text-sm shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-primary-500 transition"
                                @click="isOpen = !isOpen"
                                @keydown.arrow-down.prevent="isOpen = true; $nextTick(() => $refs.searchInput.focus())"
                                aria-haspopup="listbox"
                                :aria-expanded="isOpen"
                                aria-label="Select walk categories">
                            <span x-text="selectedOptions.length ? `${selectedOptions.length} selected` : 'Select categories'"></span>
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 transition-transform duration-200" :class="{'rotate-180': isOpen}" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z" clip-rule="evenodd" />
                            </svg>
                        </button>

                        <!-- Dropdown -->
                        <div x-show="isOpen" 
                             x-transition:enter="transition ease-out duration-200"
                             x-transition:enter-start="opacity-0 translate-y-1"
                             x-transition:enter-end="opacity-100 translate-y-0"
                             x-transition:leave="transition ease-in duration-150"
                             x-transition:leave-start="opacity-100 translate-y-0"
                             x-transition:leave-end="opacity-0 translate-y-1"
                             @click.outside="isOpen = false"
                             class="absolute z-10 mt-1 w-full rounded-md bg-white shadow-lg max-h-80 overflow-auto focus:outline-none"
                             role="listbox"
                             aria-labelledby="categories-label">
                            
                            <!-- Search Input -->
                            <div class="p-2 border-b">
                                <input type="text"
                                       x-model="searchQuery"
                                       x-ref="searchInput"
                                       placeholder="Search categories..."
                                       class="w-full rounded-md border-gray-300 px-3 py-2 text-sm focus:ring-primary-500 focus:border-primary-500"
                                       @keydown.escape.prevent.stop="isOpen = false"
                                       @keydown.arrow-down.prevent="$nextTick(() => $refs.firstOption?.focus())"
                                       @keydown.arrow-up.prevent="$nextTick(() => $refs.lastOption?.focus())"
                                       aria-label="Search categories"/>
                            </div>

                            <!-- Options List -->
                            <ul class="py-1" role="none">
                                <template x-for="(option, index) in filteredOptions" :key="option.value">
                                    <li class="relative flex items-center px-4 py-2 cursor-pointer hover:bg-gray-100 focus:bg-gray-100 outline-none"
                                        :class="{'bg-gray-100': isSelected(option)}"
                                        :style="{ borderLeft: `4px solid ${option.color}` }"
                                        @click="toggleOption(option)"
                                        @keydown.enter.prevent="toggleOption(option)"
                                        @keydown.space.prevent="toggleOption(option)"
                                        @keydown.arrow-up.prevent="$el.previousElementSibling?.focus()"
                                        @keydown.arrow-down.prevent="$el.nextElementSibling?.focus()"
                                        :x-ref="index === 0 ? 'firstOption' : (index === filteredOptions.length - 1 ? 'lastOption' : null)"
                                        tabindex="0"
                                        role="option"
                                        :aria-selected="isSelected(option)">
                                        <input type="checkbox"
                                               class="h-4 w-4 rounded border-gray-300 text-primary-600 focus:ring-primary-500"
                                               :checked="isSelected(option)"
                                               @click.stop="toggleOption(option)"
                                               aria-label="Select {{ option.label }}">
                                        <span class="ml-3 flex items-center space-x-2">
                                            <span x-text="option.emoji" class="text-lg"></span>
                                            <span x-text="option.label" class="font-medium"></span>
                                            <span class="ml-auto text-sm text-gray-500" x-text="`(${option.count})`"></span>
                                        </span>
                                    </li>
                                </template>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Walk List with HTMX loading -->
            <div id="walk-list" 
                 class="flex-1 overflow-y-auto"
                 x-ref="walkList"
                 @walk-selected.window="handleWalkSelection($event.detail)">
                <template x-if="isLoading">
                    <div class="p-4 text-center">
                        <div class="animate-spin h-5 w-5 border-2 border-primary-500 rounded-full border-t-transparent mx-auto"></div>
                        <p class="mt-2 text-sm text-gray-500">Loading walks...</p>
                    </div>
                </template>
            </div>
        </aside>

        <!-- Updated map container structure -->
        <div class="map-wrapper" :class="{ 'w-full': !showSidebar }">
            <div id="map" x-ref="map"></div>
        </div>
    </div>

    <!-- No Results Message -->
    <div id="no-results" class="hidden p-4 text-center text-gray-500">
        No walks found matching your criteria
    </div>

    <!-- Add walk card template -->
    <template id="walk-card-template">
        <div class="walk-card p-4 border-b cursor-pointer" data-walk-id="">
            <h3 class="font-semibold text-gray-900"></h3>
            <div class="mt-1 text-sm text-gray-600">
                <span class="distance"></span>
            </div>
            <div class="mt-2 flex flex-wrap gap-1 tags">
                <!-- Tags will be inserted here -->
            </div>
        </div>
    </template>
{% endblock content %}

{% block extra_js %}
<script>
    document.addEventListener('alpine:init', () => {
        Alpine.store('walks', {
            walks: [],
            selectedWalkId: Alpine.$persist(null).as('selectedWalkId'),
            map: null,
            markers: new Map(),
            filters: {
                searchQuery: Alpine.$persist('').as('searchQuery'),
                activeFilters: Alpine.$persist([]).as('activeFilters')
            },
            isLoading: false,

            async initialize() {
                try {
                    const config = JSON.parse(document.getElementById('config-data').textContent);
                    const initialWalks = JSON.parse(document.getElementById('walks-data').textContent);
                    
                    // Initialize Mapbox
                    mapboxgl.accessToken = config.mapboxToken;
                    this.initializeMap();
                    
                    // Load initial walks
                    this.setWalks(initialWalks);
                    
                    return true;
                } catch (error) {
                    console.error('Initialization failed:', error);
                    return false;
                }
            },

            initializeMap() {
                const mapContainer = document.getElementById('map');
                if (!mapContainer) throw new Error('Map container not found');

                this.map = new mapboxgl.Map({
                    container: mapContainer,
                    style: "mapbox://styles/mapbox/outdoors-v12",
                    center: [-4.85, 50.4],
                    zoom: 9.5,
                    maxBounds: [
                        [-6.5, 49.5],
                        [-3.5, 51.5]
                    ],
                    minZoom: 8,
                    maxZoom: 16
                });

                this.map.addControl(new mapboxgl.NavigationControl());
            },

            setWalks(walks) {
                this.walks = walks.filter(w => w?.id && w?.walk_name);
                this.updateMarkers();
            },

            getFilteredWalks() {
                return this.walks.filter(walk => {
                    if (this.filters.searchQuery) {
                        const term = this.filters.searchQuery.toLowerCase();
                        if (!walk.walk_name.toLowerCase().includes(term)) return false;
                    }
                    
                    if (this.filters.activeFilters.length > 0) {
                        return walk.features?.some(f => 
                            this.filters.activeFilters.includes(f)
                        );
                    }
                    
                    return true;
                });
            },

            selectWalk(walkId) {
                this.selectedWalkId = walkId;
                const walk = this.walks.find(w => w.id === walkId);
                
                if (walk?.latitude && walk?.longitude) {
                    this.map.flyTo({
                        center: [walk.longitude, walk.latitude],
                        zoom: 14,
                        duration: 1500
                    });
                }

                this.updateMarkers();
            },

            updateMarkers() {
                // Clear existing markers
                this.markers.forEach(m => m.remove());
                this.markers.clear();

                // Create new markers for filtered walks
                this.getFilteredWalks().forEach(walk => {
                    const marker = new mapboxgl.Marker({
                        color: walk.id === this.selectedWalkId ? '#DC2626' : '#3FB1CE',
                        scale: walk.id === this.selectedWalkId ? 1.2 : 1
                    })
                    .setLngLat([walk.longitude, walk.latitude])
                    .setPopup(
                        new mapboxgl.Popup({ offset: 25 })
                        .setHTML(`
                            <div class="p-3">
                                <h3 class="font-semibold">${walk.walk_name}</h3>
                                <p class="text-sm text-gray-600">${walk.steepness_level} | ${walk.distance} miles</p>
                            </div>
                        `)
                    )
                    .addTo(this.map);

                    // Add click handler
                    marker.getElement().addEventListener('click', () => {
                        this.selectWalk(walk.id);
                    });

                    this.markers.set(walk.id, marker);
                });
            },

            search(query) {
                this.filters.searchQuery = query;
                this.updateMarkers();
            },

            setFilters(filters) {
                this.filters.activeFilters = filters;
                this.updateMarkers();
            },

            cleanup() {
                this.markers.forEach(m => m.remove());
                this.markers.clear();
                if (this.map) this.map.remove();
                this.map = null;
                this.walks = [];
            }
        });
    });

    function walkInterface() {
        return function() {
            return {
                showSidebar: this.$persist(true).as('showSidebar'),
                searchQuery: this.$persist('').as('userSearchQuery'),
                activeFilters: this.$persist([]).as('userActiveFilters'),
                isLoading: true,
                
                async init() {
                    try {
                        // Ensure store is available and initialized
                        if (!Alpine.store('walks')) {
                            throw new Error('Walks store not initialized');
                        }

                        // Initialize store
                        await Alpine.store('walks').initialize();
                        
                        // Sync persisted values with store
                        if (Alpine.store('walks').ready) {
                            Alpine.store('walks').filters.searchQuery = this.searchQuery;
                            Alpine.store('walks').filters.activeFilters = this.activeFilters;
                            
                            this.$watch('searchQuery', value => {
                                Alpine.store('walks').search(value);
                            });
                            
                            this.$watch('activeFilters', value => {
                                Alpine.store('walks').setFilters(value);
                            });
                        }

                        this.isLoading = false;
                    } catch (error) {
                        console.error('Failed to initialize interface:', error);
                        this.isLoading = false;
                    }
                }
                // ...existing methods...
            }
        }
    }

    // HTMX handlers
    document.body.addEventListener('htmx:afterRequest', (evt) => {
        if (evt.detail.successful) {
            try {
                const walks = JSON.parse(evt.detail.xhr.response);
                Alpine.store('walks').setWalks(walks);
            } catch (error) {
                console.error('Failed to parse walks:', error);
            }
        }
    });
</script>

<script>
document.addEventListener('alpine:init', () => {
    Alpine.data('categoryCombobox', function(config) {
        return {
            options: config.options,
            isOpen: false,
            searchQuery: '',
            selectedOptions: this.$persist([]).as('categorySelections'),
            
            get filteredOptions() {
                return this.options.filter(option => 
                    option.label.toLowerCase().includes(this.searchQuery.toLowerCase())
                );
            },
            
            toggleOption(option) {
                const index = this.selectedOptions.findIndex(o => o.value === option.value);
                if (index === -1) {
                    this.selectedOptions.push(option);
                } else {
                    this.selectedOptions.splice(index, 1);
                }
                this.$dispatch('categories-updated', this.selectedOptions.map(o => o.value));
            },
            
            isSelected(option) {
                return this.selectedOptions.some(o => o.value === option.value);
            },
            
            clearSelection() {
                this.selectedOptions = [];
                this.$dispatch('categories-updated', []);
            }
        }
    });
});

function getCategoryEmoji(category) {
    const emojiMap = {
        'coastal': 'üèñÔ∏è',
        'woodland': 'üå≥',
        'historical': 'üèõÔ∏è',
        'scenic': 'üåÖ',
        'family-friendly': 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶',
        'challenging': 'üèÉ',
        'easy': 'üö∂',
        'moderate': '‚õ∞Ô∏è',
        'waterfall': 'üí¶',
        'wildlife': 'ü¶ä'
    };
    return emojiMap[category.toLowerCase()] || 'üö∂‚Äç‚ôÇÔ∏è';
}

function getCategoryColor(category) {
    const colorMap = {
        'coastal': '#0EA5E9',
        'woodland': '#22C55E',
        'historical': '#8B5CF6',
        'scenic': '#F59E0B',
        'family-friendly': '#EC4899',
        'challenging': '#EF4444',
        'easy': '#10B981',
        'moderate': '#6366F1',
        'waterfall': '#06B6D4',
        'wildlife': '#84CC16'
    };
    return colorMap[category.toLowerCase()] || '#6B7280';
}
</script>
{% endblock extra_js %}